Type-only imports allow to use a declaration defined elsewhere for type annotations and declarations. They are always fully erased during transpilation, therefore it reduces the amount of code loaded at runtime. Forcing type-only imports prevents issues where the file referenced in the import exports a type and the import is done for a value:

[source,javascript]
----
// ./vehicles.ts
export type Car = /*...*/;

// ./main.ts
import { Car } from './vehicles';
----

This would fail at transpilation, because the export would be erased and the import remain, thus breaking the chain.

When using the imported declaration exclusively for typing annotations and declarations, use `import type` instead of `import`.

== Noncompliant Code Example

[source,javascript]
----
import { Car } from 'vehicles';
const x: Car = /*...*/;
----

== Compliant Solution

[source,javascript]
----
import type { Car } from 'vehicles';
const x: Car = /*...*/;
----
